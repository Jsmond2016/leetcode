import{o as n,c as a,a as s}from"./app.a0fc6f0b.js";const t='{"title":"二叉树","description":"","frontmatter":{},"headers":[{"level":2,"title":"树的遍历","slug":"树的遍历"},{"level":3,"title":"前序遍历","slug":"前序遍历"},{"level":3,"title":"中序遍历","slug":"中序遍历"},{"level":3,"title":"后序遍历","slug":"后序遍历"},{"level":3,"title":"树的层序遍历","slug":"树的层序遍历"},{"level":2,"title":"树的递归","slug":"树的递归"},{"level":3,"title":"二叉树的最大深度","slug":"二叉树的最大深度"},{"level":3,"title":"对称二叉树","slug":"对称二叉树"},{"level":2,"title":"总结","slug":"总结"}],"relativePath":"leetbook/tree.md","lastUpdated":1635046375360}',p={},o=s('<h1 id="二叉树"><a class="header-anchor" href="#二叉树" aria-hidden="true">#</a> 二叉树</h1><blockquote><p>来源：<a href="https://leetcode-cn.com/leetbook/read/data-structure-binary-tree/x63shc/" target="_blank" rel="noopener noreferrer">leetbook-二叉树</a></p></blockquote><p>更多资料：</p><ul><li><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/dai-ma-sui-xiang-lu-er-cha-shu-ceng-xu-b-zhun/" target="_blank" rel="noopener noreferrer">我要打十个！二叉树层序遍历登场</a></li></ul><h2 id="树的遍历"><a class="header-anchor" href="#树的遍历" aria-hidden="true">#</a> 树的遍历</h2><h3 id="前序遍历"><a class="header-anchor" href="#前序遍历" aria-hidden="true">#</a> 前序遍历</h3><ul><li><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener noreferrer">144. 二叉树的前序遍历</a></li></ul><p>给你二叉树的根节点 root ，返回它节点值的 前序 遍历。</p><p>示例 1：</p><p>输入：root = [1,null,2,3] 输出：[1,2,3] 示例 2：</p><p>输入：root = [] 输出：[] 示例 3：</p><p>输入：root = [1] 输出：[1] 示例 4：</p><p>输入：root = [1,2] 输出：[1,2] 示例 5：</p><p>输入：root = [1,null,2] 输出：[1,2]</p><p>提示：</p><p>树中节点数目在范围 [0, 100] 内 -100 &lt;= Node.val &lt;= 100</p><p>进阶：递归算法很简单，你可以通过迭代算法完成吗？</p><hr><p>解法：</p><div class="language-js"><pre><code><span class="token comment">/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */</span>\n<span class="token comment">/**\n * @param {TreeNode} root\n * @return {number[]}\n */</span>\n<span class="token keyword">var</span> <span class="token function-variable function">preorderTraversal</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>\n\n    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>\n    <span class="token keyword">let</span> <span class="token function-variable function">order</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span> arr</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span>\n\n        <span class="token keyword">let</span> <span class="token punctuation">{</span> left<span class="token punctuation">,</span> right<span class="token punctuation">,</span> val <span class="token punctuation">}</span> <span class="token operator">=</span> node\n        arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span>\n        <span class="token function">order</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> arr<span class="token punctuation">)</span>\n        <span class="token function">order</span><span class="token punctuation">(</span>right<span class="token punctuation">,</span> arr<span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n    <span class="token function">order</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> result<span class="token punctuation">)</span>\n    <span class="token keyword">return</span> result\n<span class="token punctuation">}</span>\n\n</code></pre></div><h3 id="中序遍历"><a class="header-anchor" href="#中序遍历" aria-hidden="true">#</a> 中序遍历</h3><ul><li><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener noreferrer">94. 二叉树的中序遍历</a></li></ul><p>给定一个二叉树的根节点 root ，返回它的 中序 遍历。</p><p>示例 1：</p><p>输入：root = [1,null,2,3] 输出：[1,3,2] 示例 2：</p><p>输入：root = [] 输出：[] 示例 3：</p><p>输入：root = [1] 输出：[1] 示例 4：</p><p>输入：root = [1,2] 输出：[2,1] 示例 5：</p><p>输入：root = [1,null,2] 输出：[1,2]</p><p>提示：</p><p>树中节点数目在范围 [0, 100] 内 -100 &lt;= Node.val &lt;= 100</p><p>进阶: 递归算法很简单，你可以通过迭代算法完成吗？</p><hr><p>解法：</p><div class="language-js"><pre><code><span class="token comment">/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */</span>\n<span class="token comment">/**\n * @param {TreeNode} root\n * @return {number[]}\n */</span>\n<span class="token keyword">var</span> <span class="token function-variable function">inorderTraversal</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n   <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>\n\n    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>\n    <span class="token keyword">let</span> <span class="token function-variable function">order</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span> arr</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span>\n\n        <span class="token keyword">let</span> <span class="token punctuation">{</span> left<span class="token punctuation">,</span> right<span class="token punctuation">,</span> val <span class="token punctuation">}</span> <span class="token operator">=</span> node\n        <span class="token function">order</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> arr<span class="token punctuation">)</span>\n        arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span>\n        <span class="token function">order</span><span class="token punctuation">(</span>right<span class="token punctuation">,</span> arr<span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n    <span class="token function">order</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> result<span class="token punctuation">)</span>\n    <span class="token keyword">return</span> result\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n</code></pre></div><h3 id="后序遍历"><a class="header-anchor" href="#后序遍历" aria-hidden="true">#</a> 后序遍历</h3><ul><li><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener noreferrer">145. 二叉树的后序遍历</a></li></ul><p>给定一个二叉树，返回它的 后序 遍历。</p><p>示例:</p><p>输入: [1,null,2,3]<br> 1 <br> 2 / 3</p><p>输出: [3,2,1] 进阶: 递归算法很简单，你可以通过迭代算法完成吗？</p><hr><p>解法：</p><div class="language-js"><pre><code><span class="token comment">/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */</span>\n<span class="token comment">/**\n * @param {TreeNode} root\n * @return {number[]}\n */</span>\n<span class="token keyword">var</span> <span class="token function-variable function">postorderTraversal</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>\n    <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>\n\n    <span class="token keyword">const</span> <span class="token function-variable function">order</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span> arr</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span>\n        <span class="token keyword">const</span> <span class="token punctuation">{</span> left<span class="token punctuation">,</span> val<span class="token punctuation">,</span> right <span class="token punctuation">}</span> <span class="token operator">=</span> node<span class="token punctuation">;</span>\n        <span class="token function">order</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> arr<span class="token punctuation">)</span>\n        <span class="token function">order</span><span class="token punctuation">(</span>right<span class="token punctuation">,</span> arr<span class="token punctuation">)</span>\n        arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n    <span class="token function">order</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> res<span class="token punctuation">)</span>\n    <span class="token keyword">return</span> res\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n</code></pre></div><h3 id="树的层序遍历"><a class="header-anchor" href="#树的层序遍历" aria-hidden="true">#</a> 树的层序遍历</h3><ul><li><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener noreferrer">102. 二叉树的层序遍历</a></li></ul><p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p><p></p><p>示例： 二叉树：[3,9,20,null,null,15,7],</p><pre><code>3\n</code></pre><p>/ <br> 9 20 / <br> 15 7 返回其层序遍历结果：</p><p>[ [3], [9,20], [15,7] ]</p><hr><p>解法：</p><div class="language-js"><pre><code><span class="token keyword">var</span> <span class="token function-variable function">levelOrder</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">//二叉树的层序遍历</span>\n    <span class="token keyword">let</span> res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>queue<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n    queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">===</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n        <span class="token keyword">return</span> res<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">while</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span>length<span class="token operator">!==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n        <span class="token comment">// 记录当前层级节点数</span>\n        <span class="token keyword">let</span> length<span class="token operator">=</span>queue<span class="token punctuation">.</span>length<span class="token punctuation">;</span>\n        <span class="token comment">//存放每一层的节点 </span>\n        <span class="token keyword">let</span> curLevel<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n            <span class="token keyword">let</span> node<span class="token operator">=</span>queue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            curLevel<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token comment">// 存放当前层下一层的节点</span>\n            node<span class="token punctuation">.</span>left<span class="token operator">&amp;&amp;</span>queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            node<span class="token punctuation">.</span>right<span class="token operator">&amp;&amp;</span>queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        <span class="token comment">//把每一层的结果放到结果数组</span>\n        res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>curLevel<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">return</span> res<span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n</code></pre></div><h2 id="树的递归"><a class="header-anchor" href="#树的递归" aria-hidden="true">#</a> 树的递归</h2><h3 id="二叉树的最大深度"><a class="header-anchor" href="#二叉树的最大深度" aria-hidden="true">#</a> 二叉树的最大深度</h3><ul><li><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener noreferrer">二叉树的最大深度</a></li></ul><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例： 给定二叉树 [3,9,20,null,null,15,7]，</p><pre><code>3\n</code></pre><p>/ <br> 9 20 / <br> 15 7 返回它的最大深度 3 。</p><hr><p>解法：</p><div class="language-js"><pre><code><span class="token comment">/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */</span>\n<span class="token comment">/**\n * @param {TreeNode} root\n * @return {number}\n */</span>\n<span class="token keyword">var</span> <span class="token function-variable function">maxDepth</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n\n    <span class="token keyword">const</span> <span class="token function-variable function">dfs</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span> depth</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> node<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            res <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> depth<span class="token punctuation">)</span>\n        <span class="token punctuation">}</span>\n        <span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>\n        <span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n    <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">return</span> res\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n</code></pre></div><p>方法2：</p><div class="language-js"><pre><code><span class="token comment">/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */</span>\n<span class="token comment">/**\n * @param {TreeNode} root\n * @return {number}\n */</span>\n<span class="token keyword">var</span> <span class="token function-variable function">maxDepth</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token number">0</span>\n    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n        <span class="token keyword">const</span> left <span class="token operator">=</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">const</span> right <span class="token operator">=</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n</code></pre></div><h3 id="对称二叉树"><a class="header-anchor" href="#对称二叉树" aria-hidden="true">#</a> 对称二叉树</h3><ul><li><a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener noreferrer">对称二叉树</a></li></ul><p>给定一个二叉树，检查它是否是镜像对称的。</p><p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p><pre><code>1\n</code></pre><p>/ <br> 2 2 / \\ / <br> 3 4 4 3</p><p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p><pre><code>1\n</code></pre><p>/ <br> 2 2 \\ <br> 3 3</p><p>进阶：</p><p>你可以运用递归和迭代两种方法解决这个问题吗？</p><hr><p>解法：</p><div class="language-js"><pre><code><span class="token comment">/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */</span>\n<span class="token comment">/**\n * @param {TreeNode} root\n * @return {boolean}\n */</span>\n<span class="token keyword">var</span> <span class="token function-variable function">isSymmetric</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span>\n\n    <span class="token keyword">const</span> <span class="token function-variable function">dfs</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">left<span class="token punctuation">,</span> right</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">return</span> <span class="token boolean">true</span>\n        <span class="token punctuation">}</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">return</span> <span class="token boolean">false</span>\n        <span class="token punctuation">}</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>left<span class="token punctuation">.</span>val <span class="token operator">!==</span> right<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">return</span> <span class="token boolean">false</span>\n        <span class="token punctuation">}</span>\n        <span class="token keyword">return</span> <span class="token function">dfs</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span>left<span class="token punctuation">,</span> right<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">dfs</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span>right<span class="token punctuation">,</span> right<span class="token punctuation">.</span>left<span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">return</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n</code></pre></div><p>方法2：</p><div class="language-js"><pre><code><span class="token comment">/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */</span>\n<span class="token comment">/**\n * @param {TreeNode} root\n * @return {boolean}\n */</span>\n<span class="token keyword">var</span> <span class="token function-variable function">isSymmetric</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token function">check</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> root<span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token keyword">function</span> <span class="token function">check</span><span class="token punctuation">(</span><span class="token parameter">left<span class="token punctuation">,</span> right</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>left <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>right<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>left <span class="token operator">||</span> <span class="token operator">!</span>right<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span>\n    <span class="token keyword">return</span> left<span class="token punctuation">.</span>val <span class="token operator">===</span> right<span class="token punctuation">.</span>val <span class="token operator">&amp;&amp;</span> <span class="token function">check</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span>left<span class="token punctuation">,</span> right<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">check</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span>right<span class="token punctuation">,</span> right<span class="token punctuation">.</span>left<span class="token punctuation">)</span> \n<span class="token punctuation">}</span>\n</code></pre></div><h2 id="总结"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2>',86);p.render=function(s,t,p,e,c,l){return n(),a("div",null,[o])};export default p;export{t as __pageData};
