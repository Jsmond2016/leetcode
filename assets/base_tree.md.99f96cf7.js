import{o as n,c as s,d as a}from"./app.08f538b2.js";const p='{"title":"树","description":"","frontmatter":{},"relativePath":"base/tree.md","lastUpdated":1646556870624}',t={},o=a('<h1 id="树"><a class="header-anchor" href="#树" aria-hidden="true">#</a> 树</h1><blockquote><p>参考教程：<a href="https://leetcode-solution-leetcode-pp.gitbook.io/leetcode-solution/thinkings/tree" target="_blank" rel="noopener noreferrer">树专题</a></p></blockquote><p>dfs 模板:</p><ul><li>使用颜色标记节点的状态，新节点为白色，已访问的节点为灰色。</li><li>如果遇到的节点为白色，则将其标记为灰色，然后将其右子节点、自身、左子节点依次入栈。</li><li>如果遇到的节点为灰色，则将节点的值输出。</li></ul><p>使用栈：</p><div class="language-python"><pre><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>\n    <span class="token keyword">def</span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>\n        WHITE<span class="token punctuation">,</span> GRAY <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span>\n        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>\n        stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span>WHITE<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">]</span>\n        <span class="token keyword">while</span> stack<span class="token punctuation">:</span>\n            color<span class="token punctuation">,</span> node <span class="token operator">=</span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>\n            <span class="token keyword">if</span> node <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span> <span class="token keyword">continue</span>\n            <span class="token keyword">if</span> color <span class="token operator">==</span> WHITE<span class="token punctuation">:</span>\n                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>WHITE<span class="token punctuation">,</span> node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span>\n                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>GRAY<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">)</span>\n                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>WHITE<span class="token punctuation">,</span> node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span>\n            <span class="token keyword">else</span><span class="token punctuation">:</span>\n                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>\n        <span class="token keyword">return</span> res\n</code></pre></div><p>使用递归：</p><div class="language-js"><pre><code><span class="token keyword">const</span> visited <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n<span class="token keyword">function</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token parameter">i</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>满足特定条件）<span class="token punctuation">{</span>\n        <span class="token comment">// 返回结果 or 退出搜索空间</span>\n    <span class="token punctuation">}</span>\n\n    visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span> <span class="token comment">// 将当前状态标为已搜索</span>\n    <span class="token keyword">for</span> <span class="token punctuation">(</span>根据i能到达的下个状态j<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 如果状态j没有被搜索过</span>\n            <span class="token function">dfs</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n\n<span class="token comment">// or</span>\n\n<span class="token comment">// 前序遍历</span>\n<span class="token keyword">function</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>满足特定条件）<span class="token punctuation">{</span>\n        <span class="token comment">// 返回结果 or 退出搜索空间</span>\n    <span class="token punctuation">}</span>\n    <span class="token comment">// 主要逻辑</span>\n    <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>\n    <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n\n\n<span class="token comment">// 后续遍历</span>\n<span class="token keyword">function</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>满足特定条件）<span class="token punctuation">{</span>\n        <span class="token comment">// 返回结果 or 退出搜索空间</span>\n    <span class="token punctuation">}</span>\n    <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>\n    <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>\n    <span class="token comment">// 主要逻辑</span>\n<span class="token punctuation">}</span>\n\n</code></pre></div><p>bfs 模板：</p><ul><li>首先将根节点放入队列中。</li><li>从队列中取出第一个节点，并检验它是否为目标。如果找到目标，则结束搜索并回传结果。否则将它所有尚未检验过的直接子节点加入队列中。</li><li>若队列为空，表示整张图都检查过了——亦即图中没有欲搜索的目标。结束搜索并回传“找不到目标”。</li><li>重复步骤 2。</li></ul><p>使用队列：</p><div class="language-javascript"><pre><code><span class="token keyword">const</span> visited <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n<span class="token keyword">function</span> <span class="token function">bfs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">let</span> q <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n    q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>初始状态<span class="token punctuation">)</span>\n    <span class="token keyword">while</span><span class="token punctuation">(</span>q<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">let</span> i <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>i 是我们要找的目标<span class="token punctuation">)</span> <span class="token keyword">return</span> 结果\n        <span class="token keyword">for</span> <span class="token punctuation">(</span>i的可抵达状态j<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>j 合法<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">return</span> 没找到\n<span class="token punctuation">}</span>\n\n</code></pre></div><p>详细版：</p><div class="language-python"><pre><code><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>\n    <span class="token keyword">def</span> <span class="token function">bfs</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">:</span>\n        <span class="token comment"># 使用双端队列，而不是数组。因为数组从头部删除元素的时间复杂度为 N，双端队列的底层实现其实是链表。</span>\n        queue <span class="token operator">=</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">)</span>\n        <span class="token comment"># 记录层数</span>\n        steps <span class="token operator">=</span> <span class="token number">0</span>\n        <span class="token comment"># 需要返回的节点</span>\n        ans <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>\n        <span class="token comment"># 队列不空，生命不止！</span>\n        <span class="token keyword">while</span> queue<span class="token punctuation">:</span>\n            size <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span>\n            <span class="token comment"># 遍历当前层的所有节点</span>\n            <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">:</span>\n                node <span class="token operator">=</span> queue<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>\n                <span class="token keyword">if</span> <span class="token punctuation">(</span>step <span class="token operator">==</span> k<span class="token punctuation">)</span> ans<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">)</span>\n                <span class="token keyword">if</span> node<span class="token punctuation">.</span>right<span class="token punctuation">:</span>\n                    queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>\n                <span class="token keyword">if</span> node<span class="token punctuation">.</span>left<span class="token punctuation">:</span>\n                    queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>\n            <span class="token comment"># 遍历完当前层所有的节点后 steps + 1</span>\n            steps <span class="token operator">+=</span> <span class="token number">1</span>\n        <span class="token keyword">return</span> ans\n</code></pre></div><p>推荐大家先把本文提到的题目都做一遍，然后用本文学到的知识做一下下面十道练习题，检验一下自己的学习成果吧！</p><ul><li>剑指 Offer 55 - I.</li><li>二叉树的深度</li><li>剑指 Offer 34. 二叉树中和为某一值的路径</li><li>101 对称二叉树</li><li>226 翻转二叉树</li><li>543 二叉树的直径</li><li>662 二叉树最大宽度</li><li>971 翻转二叉树以匹配先序遍历</li><li>987 二叉树的垂序遍历</li><li>863 二叉树中所有距离为 K 的结点</li><li><a href="https://leetcode-cn.com/problems/successor-lcci/" target="_blank" rel="noopener noreferrer">面试题 04.06. 后继者</a></li></ul>',16);t.render=function(a,p,t,c,e,u){return n(),s("div",null,[o])};export default t;export{p as __pageData};
